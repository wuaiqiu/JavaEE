							gc
								-------Garbage Collector
								

1.简介

	Java中，引入了垃圾回收机制：垃圾回收器（Garbage Collector, GC），可以自动回收内存中的垃圾，
	
这是Java语言相对于其它语言的优势地方，但是内存泄漏并不会因此而完全避免。

	如果对象是在堆上分配了，而程序员又忘记进行释放，这些空间又无法自动回收，就会造成内存泄漏。
	
而无法回收的内存空间，即丢失的内存（我们称之为“垃圾”），除非是重新启动系统否则永远也不会还给操

作系统


2. 垃圾

	内存中的垃圾，即内存中已无效但又无法自动释放的空间
	
		（1）超出对象的引用句柄的作用域时，
		
				{
					Person p1 = new Person();
					……
				}
				
			引用句柄p1的作用域是从定义到“}”处，执行完这对大括号中的所有代码后，产生的Person对象就
		
		会变成垃圾，因为引用这个对象的句柄p1已超过其作用域，p1已经无效，Person对象不再被任何句柄
		
		引用了。
		
		（2）没有超出对象的引用句柄的作用域时，给这个引用句柄赋值为空时，
		
				{
					Person p1 = new Person();
					…..
					p1 = null;
					….
				}
				
		（3）创建匿名对象时，匿名对象用完以后即成垃圾:
		
				{
　　				new Person();               //因为是匿名对象，没有引用句柄指向它，即为垃圾
　　				new Person().print();
　　				//当运行完匿名对象的print()方法，这个对象也变成了垃圾
　　				……
				}
				
		

3.垃圾回收器的回收策略

		　复制式回收策略：先将正在运行中的程序暂停，然后把正在被使用的所有对象从它们所在的堆内存A里
		
复制到另一块堆内存B，再释放堆内存A中的所有空间，这些那些不再使用的对象所占用的内存空间就会被释放掉。

这种方式需要维护所需内存数量的至少两倍的内存空间，适合垃圾比较多的情况。当程序只产生了少量垃圾或者

没有垃圾时，这种回收策略的效率就非常低。

　　		自省式回收策略：首先检测所有正在使用的对象，并为它们标注，比如用1来标注正在使用的对象，

用0来标注不再被使用的对象，然后将所有标注为0的内存空间一次释放。因为标注会增大系统的开销，因此这种

方式的速度仍然很慢，尤其是在垃圾比较多的情况下，效率会很低。这种方法适合垃圾比较少的情况。



4.System.gc()方法
 
	由于Java的垃圾回收器的启用不由程序员控制，而且回收也无规律可循，并不会一产生了垃圾，垃圾回收器
	
就被唤起；有时甚至可能到程序终止，回收器都没有启动的机会。因此这个垃圾回收机制不是一个很可靠的机制。

因为垃圾不能及时回收，它们所占用的内存空间不能释放，就会影响程序的性能；如果某段程序产生大量的垃圾

而没有回收，回收工作也会变得困难。为了解决这个问题，Java提供一个System.gc()方法，可以强制启动垃圾

回收器来回收垃圾，以减少内存泄露发生的概率。


		==========================================================
			class TestJc {
				public void finalize() {
						System.out.println("Free the occupied memory...");
				}
      
				public static void main(String args[]) {
						new TestJc();
						new TestJc();
						new TestJc();
						System.gc();
						System.out.println("End of program.");
				}
			}
		
		输出:
		Free the occupied memory...
		Free the occupied memory...
		Free the occupied memory...
		End of program.
		=========================================================

		System.gc()有一个特点，就是在对象被当成垃圾从内存中释放前要调用finalize()方法，而且释放一个
		
对象调用一次finalize()方法。从程序的运行结果可以看到：垃圾回收器启动以后，并不一定马上开始回收垃圾，

很可能要等待一段时间才执行。这是因为在程序运行过程中，垃圾收集线程的优先级比较低，如果有比这个线程优

先级高的线程，先运行这些优先级高的线程，等这些线程执行完毕，才进行垃圾回收。所以System.gc()方法只是

一种“建议”，它建议Java虚拟机执行垃圾回收，释放内存空间，但什么时候能够回收就不能够预知了。