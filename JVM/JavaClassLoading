						java_class_loading
						


1.类的加载过程  

		1) 装载：
				
				查找并加载类的二进制数据(需要编译的class文件)；
	
		2)链接：
				
				验证：确保被加载类的正确性；
				
				准备：为类的静态变量分配内存，并将其初始化为默认值(0或null)；
				
				解析：把类中的符号引用转换为直接引用；
					(在java中，一个java类将会编译成一个class文件。在编译时，java类并不知道引用类的
					实际内存地址，因此只能使用符号引用来代替。比如org.simple.People类引用
					org.simple.Tool类，在编译时People类并不知道Tool类的实际内存地址，因此只
					能使用符号org.simple.Tool(假设)来表示Tool类的地址。而在类装载器装载People类时，
					此时可以通过虚拟机获取Tool类的实际内存地址，因此便可以既将符号org.simple.Tool替换
					为Tool类的实际内存地址，即直接引用地址)
		
		3)初始化：
				
				为类的静态变量赋予正确的初始值；
				
				
2.触发类加载

	1）创建类的实例，也就是new一个对象
	2）访问某个类或接口的静态变量，或者对该静态变量赋值
	3）调用类的静态方法
	4）反射（Class.forName("com.lyj.load")）
	5）初始化一个类的子类（会首先初始化子类的父类）
	
	
3.静态初始化块、初始化块、构造函数

	Java中，静态初始化块、初始化块、构造函数三者都用来完成类的初始化工作，在实际编程中可以根据不
同的需要使用不同的初始化方式，以下为三者的代码格式及Java虚拟机对三者的执行顺序分析。  

===================================================================
<p>先看一程序：</p>  
class Blocks {  
    static {  
        System.out.println("父类静态初始化块");  
    }  
   
    {  
        System.out.println("父类初始化块");  
    }  
   
    Blocks() {  
        System.out.println("父类构造函数");  
    }  
}  
   
public class InitailizeBlocks extends Blocks {  
    static {  
        System.out.println("子类静态初始化块");  
    }  
   
    {  
        System.out.println("子类初始化块");  
    }  
   
    public InitailizeBlocks() {  
        System.out.println("子类构造函数");  
    }  
   
    public static void main(String[] args) {  
        new InitailizeBlocks();  
    }  
}  
======================================================
输出结果：

父类静态初始化块
子类静态初始化块
父类初始化块
父类构造函数
子类初始化块
子类构造函数
========================================================	
分析：
	
	静态代码块在类加载时被执行，而非静态代码(包括初始化代码块和构造函数)在生成对象时才被执行，
	
故父类和子类的静态初始化代码块最早执行；初始化块与构造函数的执行顺序，前者要早于后者。