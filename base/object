							Object
						

						
1.简介（java.lang.Object）

	Object类存储在java.lang包中，是所有java类(Object类除外)的终极父类。java的任何类都继承了这些函数，
	
并且可以覆盖不被final修饰的函数。例如，没有final修饰的toString()函数可以被覆盖，但是final wait()函数

就不行。

		protected Object clone()
		boolean equals(Object obj)
		protected void finalize()
		Class< > getClass()
		int hashCode()
		void notify()
		void notifyAll()
		String toString()
		void wait()
		void wait(long timeout)
		void wait(long timeout, int nanos)


2.clone方法(可以产生一个相同的类并且返回给调用者)


		(1)浅克隆(也叫做浅拷贝)仅仅复制了这个对象本身的成员变量，该对象如果引用了其他对象的话，也不
		
对其复制。如果一个对象中的所有成员变量都是原始类型，并且其引用了的对象都是不可改变的(大多情况下都是)

时，使用浅克隆效果很好！
	
		
		(1.1)Object将clone()作为一个本地方法(protected)来实现，这意味着它的代码存放在本地的库中。
		
当代码执行的时候，将会检查调用对象的类(或者父类)是否实现了java.lang.Cloneable接口(Object类不实现

Cloneable)。如果没有实现这个接口，clone()将会抛出一个检查异常()——java.lang.CloneNotSupportedException,

如果实现了这个接口，clone()会创建一个新的对象，并将原来对象的内容复制到新对象，最后返回这个新对象

的引用。

	=======================================================================
	
	public	class	CloneDemo implements	Cloneable {

		public	static	void	main(String[] args) throws	CloneNotSupportedException {
					CloneDemo cd = new	CloneDemo();
					CloneDemo cd2 = (CloneDemo) cd.clone();
				}
		}
		
	======================================================================
	
		(1.2)调用clone()的代码是位于被克隆的类(即CloneDemo类)里面的，所以就不需要覆盖clone()了。但是，
		
如果调用别的类中的clone()，就需要覆盖clone()了

	===================================================
		
		class	Data implements	Cloneable {

			public	Object clone() throws	CloneNotSupportedException {
					return	super.clone();
				}
		}
		
		public	class	CloneDemo {
		public	static	void	main(String[] args) throws	CloneNotSupportedException {
					Data data = new	Data();
					Data data2 = (Data) data.clone();
					}
		}
	 ================================================
		
	(1.3)浅克隆在复制引用了可变对象的对象时存在的问题
	
	=================================================
	
		class	Employee implements	Cloneable {
				private	String name;
				private	Address address;
		Employee(String name, Address address) {
				this.name = name;
				this.address = address;
			}
	@Override
		public	Object clone() throws	CloneNotSupportedException {
				return	super.clone();
			}
			Address getAddress() {
			return	address;
			}
				String getName() {
					return	name;
			}
			int	getAge() {
				return	age;
			}
		}
		class	Address {
		private	String city;
		Address(String city) {
			this.city = city;
		}
			String getCity() {
			return	city;
		}
		void	setCity(String city) {
			this.city = city;
			}
		}
		public	class	CloneDemo {
			public	static	void	main(String[] args) throws	CloneNotSupportedException {
				Employee e = new	Employee("John Doe", newAddress("Denver"));
				System.out.printf("%s: %s%n", e.getName(),e.getAddress().getCity());
					Employee e2 = (Employee) e.clone();
					System.out.printf("%s: %s%n", e2.getName(),e2.getAddress().getCity());
					e.getAddress().setCity("Chicago");
					System.out.printf("%s: %s%n", e.getName(),e.getAddress().getCity());
					System.out.printf("%s: %s%n", e2.getName(), e2.getAddress().getCity());
				}
		}
		输出：
		John Doe:  Denver
		John Doe: Denver
		John Doe: Chicago
		John Doe: Chicago
		========================================================
		
		(2)深克隆(也叫做深复制)会复制这个对象和它所引用的对象的成员变量，如果该对象引用了其他对象，
	
深克隆也会对其复制

		=========================================================
		
			class	Employee implements	Cloneable {
				private	String name;
				private	Address address;
		Employee(String name, Address address) {
				this.name = name;
				this.address = address;
			}
		@Override
		public	Employee clone() throws	CloneNotSupportedException {
			Employee e=(Employee)super.clone();
			e.address=e.clone();
				return	e;
			}
			Address getAddress() {
			return	address;
			}
				String getName() {
					return	name;
			}
			int	getAge() {
				return	age;
			}
		}
		class	Address {
		private	String city;
		public	Address clone()
			{
				return	new	Address(String city);
			}
		Address(String city) {
			this.city = city;
		}
			String getCity() {
			return	city;
		}
		void	setCity(String city) {
			this.city = city;
			}
		}
		public	class	CloneDemo {
			public	static	void	main(String[] args) throws	CloneNotSupportedException {
				Employee e = new	Employee("John Doe", new	Address("Denver"));
				System.out.printf("%s: %s%n", e.getName(),e.getAddress().getCity());
					Employee e2 = (Employee) e.clone();
					System.out.printf("%s: %s%n", e2.getName(),e2.getAddress().getCity());
					e.getAddress().setCity("Chicago");
					System.out.printf("%s: %s%n", e.getName(),e.getAddress().getCity());
					System.out.printf("%s: %s%n", e2.getName(), e2.getAddress().getCity());
				}
		}
		输出：
		John Doe: Denver
		John Doe: Denver
		John Doe: Chicago
		John Doe: Denver
		
		分析:
		
		Employee类的clone()方法首先调用super().clone()，对name,address这些成员变量进行浅克隆。然后，

调用成员变量Address对象的clone()来对其引用Address对象进行克隆。

		从Address类中的clone()函数可以看出，这个clone()和我们之前写的clone()有些不同：

			Address类没有实现Cloneable接口。因为只有在Object类中的clone()被调用时才需要实现
			
(这里没有调用super.clone())，而Address是不会调用clone()的，所以没有实现Cloneable()的必要。因为

这不是对Address的对象进行浅克隆——只是一个成员变量复制而已
		
		==================================================================
		
		(4)对数组类型进行浅克隆可以利用clone()方法。对数组使用clone()时，不必将clone()的返回值类型
	
	转换为数组类型
	
	City[] cities = { newCity("Denver"), newCity("Chicago") };
	City[] cities2 = cities.clone();
	
	=======================================================================

	
		
	 
3.euqals方法
	
		equals()函数可以用来检查一个对象与调用这个equals()的这个对象是否相等
		
		虽然“==”运算符可以比较两个数据是否相等，但是要来比较对象的话，恐怕达不到预期的结果。
		
就是说，“==”通过是否引用了同一个对象来判断两个对象是否相等，这被称为“引用相等”。这个运算符不

能通过比较两个对象的内容来判断它们是不是逻辑上的相等。默认的equals()进行的是引用比较


		========================================================
		(1)对两个对象进行逻辑比较
		
				class	Employee{
					private	String name;
					private	int	age;
					Employee(String name, intage){
							this.name = name;
							this.age = age;
						}
					@Override
					public	boolean	equals(Object o){
					if(!(o instanceof	Employee))
							return	false;
					Employee e = (Employee) o;
			return	e.getName().equals(name) && e.getAge() == age;
				}
					String getName(){
						return	name;
					}
					int	getAge(){
						return	age;
					}
				}
				
		==========================================================


		
4.finalize方法

	finalize()方法可以被子类对象所覆盖，然后作为一个终结者，当GC被调用的时候完成最后的清理工作
	
（例如释放系统资源之类）。这就是终止。默认的finalize()方法什么也不做，当被调用时直接返回。

	之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。假定你的对象（并非使用new方法）
	
获得了一块“特殊”的内存区域，由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如

何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。

	通常来讲，你应该尽量避免使用finalize()。相对于其他JVM实现，终结器被调用的情况较少——可能是因为终

结器线程的优先级别较低的原因。如果你依靠终结器来关闭文件或者其他系统资源，可能会将资源耗尽，当程序

试图打开一个新的文件或者新的系统资源的时候可能会崩溃，就因为这个缓慢的终结器。




5.gerClass方法


	通过gerClass()方法可以得到一个和这个类有关的java.lang.Class对象。返回的Class对象是一个被
	
static synchronized方法封装的代表这个类的对象；例如，static sychronized void foo(){}。

这也是指向反射API。因为调用gerClass()的对象的类是在内存中的，保证了类型安全。

	获取Class对象的方法有两种。可以使用类字面常量，它的名字和类型相同，后缀位.class；例如，
	
Account.class。另外一种就是调用Class的forName()方法。类字面常量更加简洁，并且编译器强制类型安全；

如果找不到指定的类编译就不会通过。通过forName()可以动态地通过指定包名载入任意类型地引用。但是，

不能保证类型安全，可能会导致Runtime异常。



6.hashCode方法


		hashCode()方法返回给调用者此对象的哈希码（其值由一个hash函数计算得来）。这个方法通常用在
		
基于hash的集合类中，像java.util.HashMap,java.until.HashSet和java.util.Hashtable.


		
		
7.toString方法


		toString() 方法将根据调用它的对象返回其对象的字符串形式，通常用于debug
		
		当 toString() 没有被覆盖的时候，返回的字符串格式是 类名@哈希值，哈希值是十六进制的。举例说，
		
假设有一个 Employee 类，toString() 方法返回的结果可能是 Empoyee@1c7b0f4d。
	
		============================================
		
		public	class	Employee{
			private	String name;
			private	int	age;
		public	Employee(String name, intage){
			this.name = name;
			this.age = age;
		}
		@Override
		public	String toString(){
			return	name + ": "+ age;
			}
		
		}
		===========================================

		
8.wait()，notify() 和 notifyAll() 

	wait()，notify() 和 notifyAll() 可以让线程协调完成一项任务。