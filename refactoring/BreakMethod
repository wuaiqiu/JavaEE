						Break Method
						
				
1.Break Method【分解方法】

	
=========================================================================

	实例：
	
		 public class CashRegister{
			public CashRegister(){
            Tax = 0.06f;
			}

			private float Tax ;

			public void AcceptPayment(Customer customer, List<Product> products, int payment){
				float subTotal = 0f;
				for (Product product : products){
					subTotal += product.Price;
				}

				for (Product product : products){
					subTotal -= product.AvailableDiscounts;
				}

				float grandTotal = subTotal * Tax;

				customer.DeductFromAccountBalance(grandTotal);
			}	
		}

		public class Customer{
			public void DeductFromAccountBalance(float amount){
            // deduct from balance
			}
		}

		public class Product{
			public int Price ;
			public int AvailableDiscounts ;
		}
		
		
-----------------------------解决方案------------------------------------

	 public class CashRegister2{
        public CashRegister2(){
            Tax = 0.06f;
        }

        private float Tax ;
        private List<Product> Products;

        public void AcceptPayment(Customer customer, List<Product> products, int payment){
            int subTotal = CalculateSubtotal();

            subTotal = SubtractDiscounts(subTotal);

            float grandTotal = AddTax(subTotal);

            SubtractFromCustomerBalance(customer, grandTotal);
        }

        private void SubtractFromCustomerBalance(Customer customer, float grandTotal){
            customer.DeductFromAccountBalance(grandTotal);
        }

        private float AddTax(int subTotal){
            return subTotal * Tax;
        }

        private int SubtractDiscounts(int subTotal){
            for (Product product : Products){
                subTotal -= product.AvailableDiscounts;
            }
            return subTotal;
        }

        private int CalculateSubtotal(){
            int subTotal = 0;
            for (Product product : Products){
                subTotal += product.Price;
            }
            return subTotal;
        }
    }
	
	

2.Remove Arrowhead Antipattern【去除复杂的嵌套条件判断】

	对于复杂的逻辑判断if else{if else ..}类似这样嵌套判断，可以有一些重构的技巧
	
	
================================================================================

	实例：
		
			public class Security{
				public List list;

			public Security(List list){
				this.list = list;
			}

			public boolean HasAccess(Date date, String []arrs, List<String> exemptions){
				boolean hasPermission = false;

            if (date != null){
                if (arrs != null){
                    if (arrs.length == 0){
                        if (null!=exemptions&&exemptions.get(0).equals("abc")){
                            hasPermission = true;
                        }
                    }
                }
            }

            return hasPermission;
		}
    }
	
	
---------------------------------解决方案------------------------------------

	public boolean HasAccess2(Date date, String[] arrs, List<String> exemptions) {
            boolean hasPermission = false;

            if (date == null||arrs==null) {
                return false;
            }
            if(arrs.length!=0){
                return false;
            }
            if (null != exemptions && exemptions.get(0).equals("abc")) {
                return  true;
            }

            return false;
        }
		
		
		
		
3.Remove Double Negative【消除双重否定】

		public class Day_26 {
			static boolean isEmpty(String str){

			if(null==str||str.length()==0){

				return true;
			}
			return false;

		}

		static boolean isNotEmpty(String str){	

			return !isEmpty(str);

		}


		public static void main(String[] args) {

			if(!isEmpty("")){

        }
       
        if(isNotEmpty("")){
               
			}
		}
	}
	
	
	
	
4.Remove God Classes【去除上帝类】

		就是一些“功能强大的工具/管理类”，他可能庞大到整个业务系统只会有一个的工具类，
	
这样就违反了单一责任原则。

=================================================================================

	实例：
		
public class CustomerService {
        public int CalculateOrderDiscount(String str) {
            // do work
            return 0;
        }

        public boolean CustomerIsValid(String str) {
            // do work
            return true;
        }

        public List<String> GatherOrderErrors() {
            // do work
            return null;
        }

        public void Register(Object customer) {
            // do work
        }

        public void ForgotPassword(Object customer) {
            // do work
        }
    }
	
	
-------------------解决方案------------------------------------

	 public class CustomerService2 {
        public int CalculateOrderDiscount(String str) {
            // do work
            return 0;
        }

        public boolean CustomerIsValid(String str) {
            // do work
            return true;
        }

        public List<String> GatherOrderErrors() {
            // do work
            return null;
        }


    }

    public class  CustomerRegistrationService{

        public void Register(Object customer) {
            // do work
        }

        public void ForgotPassword(Object customer) {
            // do work
        }
    }
	
	
	

5.Remove Middle Man【去除中间人】

	简单理解，就是当A需要通过B去访问C的时候，并且B除了调用C的方法，不在有任何作用的时候，
	
则B就成了所谓的中间人，就应该被delete掉


==================================================================================

	实例：
	
	public class Consumer {
        public AccountManager AccountManager;

        public Consumer(AccountManager accountManager) {
            AccountManager = accountManager;
        }

        public void Get(int id) {
            Account account = AccountManager.GetAccount(id);
        }
    }

    public class AccountManager {
        public AccountDataProvider DataProvider;

        public AccountManager(AccountDataProvider dataProvider) {
            DataProvider = dataProvider;
        }

        public Account GetAccount(int id) {
            return DataProvider.GetAccount(id);
        }
    }

    public class AccountDataProvider {
        public Account GetAccount(int id) {
            // get account
            return null;
        }
    }

    class Account {

    }
	
	
------------------------------解决方案------------------------------------

	public class Consumer2{
        public AccountDataProvider AccountDataProvider ;

        public Consumer2(AccountDataProvider dataProvider){
            AccountDataProvider = dataProvider;
        }

        public void Get(int id){
            Account account = AccountDataProvider.GetAccount(id);
        }
    }
	
	
	
6.Return ASAP【尽快返回】

	即对之前的复杂逻辑判断的一个侧面说明了
	
==========================================================================

	实例：
	
	public class Order {
        public Object Customer;

        public int CalculateOrder(Object customer, List<Object> products, int discounts) {
            Customer = customer;
            int orderTotal = 0;

            if (products.size() > 0) {
                orderTotal = products.size();
                if (discounts > 0) {
                    orderTotal -= discounts;
                }
            }

            return orderTotal;
        }
    }
	
	
------------------------解决方案------------------------------------

	 public class Order2 {
        public Object Customer;

        public int CalculateOrder(Object customer, List<Object> products, int discounts) {
            Customer = customer;
            int orderTotal = 0;

            if (products.size() == 0) {
                return 0;
            }

            orderTotal = products.size();
            if (discounts > 0) {
                orderTotal -= discounts;
            }

            return orderTotal;
        }
    }